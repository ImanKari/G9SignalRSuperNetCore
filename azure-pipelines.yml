trigger:
- master

pool:
  vmImage: 'windows-latest'

parameters:
  - name: solutionPath
    type: string
    default: 'G9SignalRSuperNetCore/G9SignalRSuperNetCore.sln'
  - name: testProjects
    type: string
    default: 'null' # Leave empty if no test projects are defined
  - name: nugetPackages
    type: object
    default:
      - 'G9SignalRSuperNetCore/G9SignalRSuperNetCore.Client/bin/Release/*.nupkg'
      - 'G9SignalRSuperNetCore/G9SignalRSuperNetCore.Server/bin/Release/*.nupkg'
  - name: repositoryName
    type: string
    default: 'G9SignalRSuperNetCore' # Default to the same as the project name

variables:
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'

steps:

# Install NuGet tool
- task: NuGetToolInstaller@1

# Restore NuGet packages
- task: NuGetCommand@2
  inputs:
    restoreSolution: '${{ parameters.solutionPath }}'

- task: VSBuild@1
  displayName: Build Client Resource Generator
  inputs:
    solution: 'G9SignalRSuperNetCore/G9SignalRSuperNetCore.Server.ClientResourceGenerator/G9SignalRSuperNetCore.Server.ClientResourceGenerator.csproj'
    msbuildArgs: '/p:Configuration=$(buildConfiguration) /p:TargetFramework=netstandard2.0'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

# Build the solution
- task: VSBuild@1
  inputs:
    solution: '${{ parameters.solutionPath }}'
    msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:ContinuousIntegrationBuild=true /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="$(build.artifactStagingDirectory)"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

# Set runtime variable for tests
- task: Bash@3
  displayName: "Evaluate Test Projects"
  inputs:
    targetType: 'inline'
    script: |
      if [ "${{ parameters.testProjects }}" != "null" ]; then
        echo "##vso[task.setvariable variable=runTests]true"
      else
        echo "##vso[task.setvariable variable=runTests]false"
      fi

# Run tests if applicable
- ${{ if eq(variables.runTests, 'true') }}:
  - task: VSTest@2
    displayName: Run Unit Tests
    inputs:
      testSelector: testAssemblies
      testAssemblyVer2: '${{ parameters.testProjects }}'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

# Validate and publish NuGet packages
- ${{ each packagePath in parameters.nugetPackages }}:
  - task: PowerShell@2
    displayName: "Publish NuGet Package - ${{ packagePath }}"
    inputs:
      targetType: 'inline'
      script: |
        Write-Host "==============================================="
        Write-Host "Starting NuGet Package Publishing Process"
        Write-Host "==============================================="
        
        # Display current working directory and package path
        Write-Host "Current Directory: $(Get-Location)"
        $packagePath = "${{ packagePath }}"
        Write-Host "Looking for packages in: $packagePath"
        
        # Verify path exists
        if (-not (Test-Path (Split-Path $packagePath -Parent))) {
            Write-Host "##vso[task.logissue type=warning]Parent directory does not exist: $(Split-Path $packagePath -Parent)"
            Write-Host "Directory Structure:"
            Get-ChildItem -Path "$(Get-Location)" -Recurse -Directory | Select-Object FullName | Format-Table
            throw "Parent directory not found"
        }
        
        # Try to find packages
        try {
            $packages = Get-ChildItem -Path $packagePath -ErrorAction Stop
            Write-Host "Found $($packages.Count) package(s)"
        }
        catch {
            Write-Host "##vso[task.logissue type=error]Error searching for packages: $_"
            Write-Host "Contents of parent directory:"
            Get-ChildItem -Path (Split-Path $packagePath -Parent) -Force | Format-Table Name, LastWriteTime, Length
            throw "Failed to locate packages"
        }
        
        # If no packages found
        if ($packages.Count -eq 0) {
            Write-Host "##vso[task.logissue type=warning]No packages found matching pattern: $packagePath"
            Write-Host "Searching nearby directories for .nupkg files..."
            $nearbyPackages = Get-ChildItem -Path (Split-Path $packagePath -Parent) -Recurse -Filter "*.nupkg"
            if ($nearbyPackages) {
                Write-Host "Found these .nupkg files in nearby directories:"
                $nearbyPackages | ForEach-Object {
                    Write-Host " - $($_.FullName)"
                }
            }
            throw "No packages found to publish"
        }
        
        # Process each package
        foreach ($package in $packages) {
            Write-Host "`n-------------------------------------------"
            Write-Host "Processing package: $($package.Name)"
            Write-Host "Full path: $($package.FullName)"
            Write-Host "Last modified: $($package.LastWriteTime)"
            Write-Host "Size: $([math]::Round($package.Length / 1KB, 2)) KB"
            Write-Host "-------------------------------------------"
            
            # Verify package exists and is readable
            if (-not (Test-Path $package.FullName -PathType Leaf)) {
                Write-Host "##vso[task.logissue type=error]Package file no longer exists or is not accessible: $($package.FullName)"
                continue
            }
            
            # Verify package is a valid .nupkg file
            if (-not $package.Extension -eq ".nupkg") {
                Write-Host "##vso[task.logissue type=warning]File is not a .nupkg file: $($package.FullName)"
                continue
            }
            
            # Attempt to publish
            try {
                Write-Host "Attempting to publish package..."
                $output = & dotnet nuget push $package.FullName --api-key $(NuGetApiKey) --source https://api.nuget.org/v3/index.json --skip-duplicate 2>&1
                Write-Host "Push command output:"
                Write-Host $output
                
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "##vso[task.logissue type=success]Successfully published package: $($package.Name)"
                } else {
                    Write-Host "##vso[task.logissue type=error]Failed to publish package. Exit code: $LASTEXITCODE"
                    throw "Package push failed with exit code $LASTEXITCODE"
                }
            }
            catch {
                Write-Host "##vso[task.logissue type=error]Exception while publishing package: $_"
                throw "Failed to publish package: $_"
            }
        }
        
        Write-Host "`n==============================================="
        Write-Host "Package Publishing Process Complete"
        Write-Host "==============================================="

# Sync Azure DevOps repo with GitHub repo
- task: PowerShell@2
  displayName: "Sync Azure DevOps repo with GitHub repo"
  inputs:
    targetType: 'inline'
    script: |
      Write-Host ' - - - - - - - - - - - - - - - - - - - - - - - - -'
      Write-Host ' Reflect Azure DevOps repo changes to GitHub repo'
      Write-Host ' - - - - - - - - - - - - - - - - - - - - - - - - - '
      
      $repoName = "${{ parameters.repositoryName }}"
      $stageDir = "$(Build.SourcesDirectory)"
      $githubDir = "$stageDir/gitHub"
      $destination = "$githubDir/$repoName.git"

      # Please provide your GitHub username
      $alias = "ImanKari:" + "$(Github.PAT)"

      # Source and destination repository URLs
      $sourceURL = "https://$(AzureDevOps.PAT)@dev.azure.com/YourOrg/_git/$repoName"
      $destURL = "https://$alias@github.com/ImanKari/$repoName.git"

      # Ensure the directory structure is clean
      if (Test-Path -Path $githubDir) {
        Remove-Item -Path $githubDir -Recurse -Force
      }

      New-Item -ItemType Directory -Path $githubDir | Out-Null
      Set-Location $githubDir

      # Clone the repository
      git clone --mirror $sourceURL
      Set-Location $destination

      # Sync changes
      git remote add --mirror=fetch secondary $destURL
      git fetch origin
      git push secondary --all
      git push secondary --tags

      Write-Host '**Azure DevOps repo synced with GitHub repo**'

      # Cleanup
      Set-Location $stageDir
      if (Test-Path -Path $githubDir) {
        Remove-Item -Path $githubDir -Recurse -Force
      }
