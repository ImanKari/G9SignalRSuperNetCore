trigger:
- master

pool:
  vmImage: 'windows-latest'

parameters:
  - name: solutionPath
    type: string
    default: 'G9SignalRSuperNetCore/G9SignalRSuperNetCore.sln'
  - name: testProjects
    type: string
    default: 'null' # Leave empty if no test projects are defined
  - name: nugetPackages
    type: object
    default:
      - 'G9SignalRSuperNetCore/G9SignalRSuperNetCore.Client/bin/Release/*.nupkg'
      - 'G9SignalRSuperNetCore/G9SignalRSuperNetCore.Server/bin/Release/*.nupkg'
      - 'G9SignalRSuperNetCore/G9SignalRSuperNetCore.Server.ClientInterfaceGenerator/bin/Release/*.nupkg'
  - name: repositoryName
    type: string
    default: 'G9SignalRSuperNetCore' # Default to the same as the project name

variables:
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'

steps:

# Install NuGet tool
- task: NuGetToolInstaller@1

# Restore NuGet packages
- task: NuGetCommand@2
  inputs:
    restoreSolution: '${{ parameters.solutionPath }}'

- task: VSBuild@1
  displayName: Build Client Resource Generator
  inputs:
    solution: 'G9SignalRSuperNetCore/G9SignalRSuperNetCore.Server.ClientResourceGenerator/G9SignalRSuperNetCore.Server.ClientResourceGenerator.csproj'
    msbuildArgs: '/p:Configuration=$(buildConfiguration) /p:TargetFramework=netstandard2.0 /p:CopyLocalLockFileAssemblies=true'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: PowerShell@2
  displayName: 'Verify Resource Generator Build Output'
  inputs:
    targetType: 'inline'
    script: |
      $outputPath = "D:\a\1\s\G9SignalRSuperNetCore\G9SignalRSuperNetCore.Server.ClientResourceGenerator\bin\Release\netstandard2.0"
      Write-Host "Checking contents of: $outputPath"
      if (Test-Path $outputPath) {
        Get-ChildItem $outputPath -Recurse | ForEach-Object {
          Write-Host $_.FullName
        }
      } else {
        Write-Host "##vso[task.logissue type=warning]Output directory does not exist"
      }

- task: NuGetCommand@2
  displayName: 'Restore Resource Generator packages'
  inputs:
    command: 'restore'
    restoreSolution: 'G9SignalRSuperNetCore/G9SignalRSuperNetCore.Server.ClientResourceGenerator/G9SignalRSuperNetCore.Server.ClientResourceGenerator.csproj'
    feedsToUse: 'select'

- task: PowerShell@2
  displayName: 'Install and Copy Roslyn Dependencies'
  inputs:
    targetType: 'inline'
    script: |
      # Create target directory
      $targetDir = "D:\a\1\s\G9SignalRSuperNetCore\G9SignalRSuperNetCore.Server.ClientResourceGenerator\bin\Release\netstandard2.0"
      New-Item -ItemType Directory -Path $targetDir -Force
      
      # Install required packages
      dotnet add "D:\a\1\s\G9SignalRSuperNetCore\G9SignalRSuperNetCore.Server.ClientResourceGenerator\G9SignalRSuperNetCore.Server.ClientResourceGenerator.csproj" package Microsoft.CodeAnalysis --version 4.8.0
      dotnet add "D:\a\1\s\G9SignalRSuperNetCore\G9SignalRSuperNetCore.Server.ClientResourceGenerator\G9SignalRSuperNetCore.Server.ClientResourceGenerator.csproj" package Microsoft.CodeAnalysis.CSharp --version 4.8.0
      
      # Build the project to ensure packages are restored
      dotnet build "D:\a\1\s\G9SignalRSuperNetCore\G9SignalRSuperNetCore.Server.ClientResourceGenerator\G9SignalRSuperNetCore.Server.ClientResourceGenerator.csproj" -c Release
      
      # Find and copy the DLLs
      $nugetCache = "C:\Users\VssAdministrator\.nuget\packages"
      Get-ChildItem -Path $nugetCache -Recurse -Filter "Microsoft.CodeAnalysis.dll" | Where-Object { $_.FullName -like "*\lib\netstandard2.0\*" } | Copy-Item -Destination $targetDir -Force
      Get-ChildItem -Path $nugetCache -Recurse -Filter "Microsoft.CodeAnalysis.CSharp.dll" | Where-Object { $_.FullName -like "*\lib\netstandard2.0\*" } | Copy-Item -Destination $targetDir -Force
      
      # Verify the files
      Write-Host "Contents of target directory:"
      Get-ChildItem $targetDir | Format-Table Name, Length, LastWriteTime

# Build the solution
- task: VSBuild@1
  inputs:
    solution: '${{ parameters.solutionPath }}'
    msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:ContinuousIntegrationBuild=true /p:PackageAsSingleFile=true /p:SkipInvalidConfigurations=true /p:PackageLocation="$(build.artifactStagingDirectory)"'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

# Set runtime variable for tests
- task: Bash@3
  displayName: "Evaluate Test Projects"
  inputs:
    targetType: 'inline'
    script: |
      if [ "${{ parameters.testProjects }}" != "null" ]; then
        echo "##vso[task.setvariable variable=runTests]true"
      else
        echo "##vso[task.setvariable variable=runTests]false"
      fi

# Run tests if applicable
- ${{ if eq(variables.runTests, 'true') }}:
  - task: VSTest@2
    displayName: Run Unit Tests
    inputs:
      testSelector: testAssemblies
      testAssemblyVer2: '${{ parameters.testProjects }}'
      platform: '$(buildPlatform)'
      configuration: '$(buildConfiguration)'

# Validate and publish NuGet packages
- ${{ each packagePath in parameters.nugetPackages }}:
  - task: PowerShell@2
    displayName: "Publish NuGet Package - ${{ packagePath }}"
    inputs:
      targetType: 'inline'
      script: |
        Write-Host "==============================================="
        Write-Host "Starting NuGet Package Publishing Process"
        Write-Host "==============================================="
        
        # Display current working directory and package path
        Write-Host "Current Directory: $(Get-Location)"
        $packagePath = "${{ packagePath }}"
        Write-Host "Looking for packages in: $packagePath"
        
        # Verify path exists
        if (-not (Test-Path (Split-Path $packagePath -Parent))) {
            Write-Host "##vso[task.logissue type=warning]Parent directory does not exist: $(Split-Path $packagePath -Parent)"
            Write-Host "Directory Structure:"
            Get-ChildItem -Path "$(Get-Location)" -Recurse -Directory | Select-Object FullName | Format-Table
            throw "Parent directory not found"
        }
        
        # Try to find packages
        try {
            $packages = Get-ChildItem -Path $packagePath -ErrorAction Stop
            Write-Host "Found $($packages.Count) package(s)"
        }
        catch {
            Write-Host "##vso[task.logissue type=error]Error searching for packages: $_"
            Write-Host "Contents of parent directory:"
            Get-ChildItem -Path (Split-Path $packagePath -Parent) -Force | Format-Table Name, LastWriteTime, Length
            throw "Failed to locate packages"
        }
        
        # If no packages found
        if ($packages.Count -eq 0) {
            Write-Host "##vso[task.logissue type=warning]No packages found matching pattern: $packagePath"
            Write-Host "Searching nearby directories for .nupkg files..."
            $nearbyPackages = Get-ChildItem -Path (Split-Path $packagePath -Parent) -Recurse -Filter "*.nupkg"
            if ($nearbyPackages) {
                Write-Host "Found these .nupkg files in nearby directories:"
                $nearbyPackages | ForEach-Object {
                    Write-Host " - $($_.FullName)"
                }
            }
            throw "No packages found to publish"
        }
        
        # Process each package
        foreach ($package in $packages) {
            Write-Host "`n-------------------------------------------"
            Write-Host "Processing package: $($package.Name)"
            Write-Host "Full path: $($package.FullName)"
            Write-Host "Last modified: $($package.LastWriteTime)"
            Write-Host "Size: $([math]::Round($package.Length / 1KB, 2)) KB"
            Write-Host "-------------------------------------------"
            
            # Verify package exists and is readable
            if (-not (Test-Path $package.FullName -PathType Leaf)) {
                Write-Host "##vso[task.logissue type=error]Package file no longer exists or is not accessible: $($package.FullName)"
                continue
            }
            
            # Verify package is a valid .nupkg file
            if (-not $package.Extension -eq ".nupkg") {
                Write-Host "##vso[task.logissue type=warning]File is not a .nupkg file: $($package.FullName)"
                continue
            }
            
            # Attempt to publish
            try {
                Write-Host "Attempting to publish package..."
                $output = & dotnet nuget push $package.FullName --api-key $(NuGetApiKey) --source https://api.nuget.org/v3/index.json --skip-duplicate 2>&1
                Write-Host "Push command output:"
                Write-Host $output
                
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "Successfully published package: $($package.Name)"
                } else {
                    Write-Host "##vso[task.logissue type=error]Failed to publish package. Exit code: $LASTEXITCODE"
                    throw "Package push failed with exit code $LASTEXITCODE"
                }
            }
            catch {
                Write-Host "##vso[task.logissue type=error]Exception while publishing package: $_"
                throw "Failed to publish package: $_"
            }
        }
        
        Write-Host "`n==============================================="
        Write-Host "Package Publishing Process Complete"
        Write-Host "==============================================="

- task: PowerShell@2
  displayName: "Sync Azure Devops repo with GitHub repo"
  inputs:
    targetType: 'inline'
    script: |
      # Write your PowerShell commands here.
      Write-Host ' - - - - - - - - - - - - - - - - - - - - - - - - -'
      Write-Host ' reflect Azure Devops repo changes to GitHub repo'
      Write-Host ' - - - - - - - - - - - - - - - - - - - - - - - - - '
      $stageDir = '$(Build.SourcesDirectory)' | Split-Path
      $githubDir = $stageDir +"\"+"gitHub"
      $repoName = "${{ parameters.repositoryName }}"
      $destination = $githubDir +"\"+$repoName+".git"
      #please provide your username
      $alias = 'ImanKari:'+ "$(Github.PAT)"
      #Please make sure, you remove https from azure-repo-clone-url
      $sourceURL = 'https://$(AzureDevOps.PAT)@g9tm.visualstudio.com/'+$repoName+'/_git/'+ $repoName
      #Please make sure, you remove https from github-repo-clone-url
      $destURL = 'https://' + $alias + '@github.com/ImanKari/'+$repoName+'.git'
      #Check if the parent directory exists and delete
      if((Test-Path -path $githubDir))
      {
        Remove-Item -Path $githubDir -Recurse -force
      }
      if(!(Test-Path -path $githubDir))
      {
        New-Item -ItemType directory -Path $githubDir
        Set-Location $githubDir
        git clone --mirror $sourceURL
      }
      else
      {
        Write-Host "The given folder path $githubDir already exists";
      }
      Set-Location $destination
      Write-Output '*****Ignore gient file****'
      git rm --cached giant_file
      git commit --amend -CHEAD
      Write-Output '*****Git removing remote secondary****'
      git remote rm secondary
      Write-Output '*****Git remote add****'
      git remote add --mirror=fetch secondary $destURL
      Write-Output '*****Git fetch origin****'
      git fetch $sourceURL
      Write-Output '*****Git push secondary****'
      git push secondary --all
      Write-Output '**Azure Devops repo synced with Github repo**'
      Set-Location $stageDir
      if((Test-Path -path $githubDir))
      {
        Remove-Item -Path $githubDir -Recurse -force
      }
